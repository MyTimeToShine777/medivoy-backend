{'role': 'assistant', 'content': 'Let\'s start by fixing the auth.controller.js file since it\'s one of the most important controllers:\n\n<function_calls>\n<full-file-rewrite file_path="src/controllers/auth.controller.js">\nconst bcrypt = require(\'bcrypt\');\nconst jwt = require(\'jsonwebtoken\');\nconst { validationResult } = require(\'express-validator\');\nconst User = require(\'../models/User.model\');\nconst Patient = require(\'../models/Patient.model\');\nconst Doctor = require(\'../models/Doctor.model\');\nconst Hospital = require(\'../models/Hospital.model\');\nconst {\n  generateAccessToken,\n  generateRefreshToken,\n} = require(\'../utils/jwt\');\nconst config = require(\'../config\');\nconst logger = require(\'../utils/logger\');\nconst { sendWelcomeEmail } = require(\'../services/email.service\');\nconst RefreshToken = require(\'../models/RefreshToken.model\');\nconst {\n  successResponse,\n  errorResponse,\n} = require(\'../utils/response\');\n\nclass AuthController {\n  /**\n   * Register a new user\n   */\n  async register(req, res) {\n    try {\n      // Check for validation errors\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return errorResponse(res, {\n          message: \'Validation failed\',\n          errors: errors.array(),\n        }, 400);\n      }\n\n      const {\n        email,\n        password,\n        firstName,\n        lastName,\n        role,\n        phone,\n      } = req.body;\n\n      // Check if user already exists\n      const existingUser = await User.findOne({ where: { email } });\n      if (existingUser) {\n        return errorResponse(res, {\n          message: \'User with this email already exists\',\n          code: \'USER_EMAIL_EXISTS\',\n        }, 409);\n      }\n\n      // Hash password\n      const saltRounds = config.bcryptSaltRounds;\n      const hashedPassword = await bcrypt.hash(password, saltRounds);\n\n      // Create user\n      const user = await User.create({\n        email,\n        password: hashedPassword,\n        firstName,\n        lastName,\n        role,\n        phone,\n      });\n\n      // Create role-specific profile\n      if (role === \'patient\') {\n        await Patient.create({\n          userId: user.id,\n          dateOfBirth: null,\n          gender: null,\n          bloodType: null,\n          emergencyContact: null,\n        });\n      } else if (role === \'doctor\') {\n        await Doctor.create({\n          userId: user.id,\n          specialty: null,\n          licenseNumber: null,\n          yearsOfExperience: null,\n        });\n      } else if (role === \'hospital_admin\') {\n        await Hospital.create({\n          userId: user.id,\n          name: null,\n          address: null,\n          phone: null,\n          licenseNumber: null,\n        });\n      }\n\n      // Generate tokens\n      const accessToken = generateAccessToken(user);\n      const refreshToken = generateRefreshToken(user);\n\n      // Save refresh token\n      await RefreshToken.create({\n        token: refreshToken,\n        userId: user.id,\n      });\n\n      // Send welcome email\n      await sendWelcomeEmail(user.email, user.firstName);\n\n      // Return success response\n      return successResponse(res, {\n        message: \'User registered successfully\',\n        data: {\n          user: {\n            id: user.id,\n            email: user.email,\n            firstName: user.firstName,\n            lastName: user.lastName,\n            role: user.role,\n          },\n          accessToken,\n          refreshToken,\n        },\n      }, 201);\n    } catch (error) {\n      logger.error(\'Registration error:\', error);\n      return errorResponse(res, {\n        message: \'Registration failed\',\n        error: error.message,\n      }, 500);\n    }\n  }\n\n  /**\n   * Login user\n   */\n  async login(req, res) {\n    try {\n      // Check for validation errors\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return errorResponse(res, {\n          message: \'Validation failed\',\n          errors: errors.array(),\n        }, 400);\n      }\n\n      const { email, password } = req.body;\n\n      // Find user\n      const user = await User.findOne({ where: { email } });\n      if (!user) {\n        return errorResponse(res, {\n          message: \'Invalid credentials\',\n          code: \'AUTH_INVALID_CREDENTIALS\',\n        }, 401);\n      }\n\n      // Check password\n      const isPasswordValid = await bcrypt.compare(password, user.password);\n      if (!isPasswordValid) {\n        return errorResponse(res, {\n          message: \'Invalid credentials\',\n          code: \'AUTH_INVALID_CREDENTIALS\',\n        }, 401);\n      }\n\n      // Check if account is verified\n      if (!user.isVerified) {\n        return errorResponse(res, {\n          message: \'Please verify your account\',\n          code: \'AUTH_ACCOUNT_NOT_VERIFIED\',\n        }, 401);\n      }\n\n      // Generate tokens\n      const accessToken = generateAccessToken(user);\n      const refreshToken = generateRefreshToken(user);\n\n      // Save or update refresh token\n      await RefreshToken.upsert({\n        token: refreshToken,\n        userId: user.id,\n      });\n\n      // Return success response\n      return successResponse(res, {\n        message: \'Login successful\',\n        data: {\n          user: {\n            id: user.id,\n            email: user.email,\n            firstName: user.firstName,\n            lastName: user.lastName,\n            role: user.role,\n          },\n          accessToken,\n          refreshToken,\n        },\n      });\n    } catch (error) {\n      logger.error(\'Login error:\', error);\n      return errorResponse(res, {\n        message: \'Login failed\',\n        error: error.message,\n      }, 500);\n    }\n  }\n\n  /**\n   * Refresh access token\n   */\n  async refresh(req, res) {\n    try {\n      const { refreshToken } = req.body;\n\n      // Verify refresh token\n      const decoded = jwt.verify(refreshToken, config.jwt.refreshSecret);\n\n      // Find user\n      const user = await User.findByPk(decoded.id);\n      if (!user) {\n        return errorResponse(res, {\n          message: \'Invalid refresh token\',\n          code: \'AUTH_TOKEN_INVALID\',\n        }, 401);\n      }\n\n      // Check if refresh token exists in database\n      const storedToken = await RefreshToken.findOne({\n        where: {\n          token: refreshToken,\n          userId: user.id,\n        },\n      });\n\n      if (!storedToken) {\n        return errorResponse(res, {\n          message: \'Invalid refresh token\',\n          code: \'AUTH_TOKEN_INVALID\',\n        }, 401);\n      }\n\n      // Generate new tokens\n      const newAccessToken = generateAccessToken(user);\n      const newRefreshToken = generateRefreshToken(user);\n\n      // Update refresh token in database\n      await RefreshToken.update(\n        { token: newRefreshToken },\n        { where: { userId: user.id } },\n      );\n\n      // Return success response\n      return successResponse(res, {\n        message: \'Token refreshed successfully\',\n        data: {\n          accessToken: newAccessToken,\n          refreshToken: newRefreshToken,\n        },\n      });\n    } catch (error) {\n      logger.error(\'Token refresh error:\', error);\n      return errorResponse(res, {\n        message: \'Token refresh failed\',\n        error: error.message,\n      }, 401);\n    }\n  }\n\n  /**\n   * Logout user\n   */\n  async logout(req, res) {\n    try {\n      const { user } = req;\n\n      // Remove refresh token from database\n      await RefreshToken.destroy({\n        where: { userId: user.id },\n      });\n\n      // Return success response\n      return successResponse(res, {\n        message: \'Logout successful\',\n      });\n    } catch (error) {\n      logger.error(\'Logout error:\', error);\n      return errorResponse(res, {\n        message: \'Logout failed\',\n        error: error.message,\n      }, 500);\n    }\n  }\n\n  /**\n   * Get user profile\n   */\n  async getProfile(req, res) {\n    try {\n      const { user } = req;\n\n      // Return success response\n      return successResponse(res, {\n        message: \'Profile retrieved successfully\',\n        data: {\n          user: {\n            id: user.id,\n            email: user.email,\n            firstName: user.firstName,\n            lastName: user.lastName,\n            role: user.role,\n            phone: user.phone,\n            isVerified: user.isVerified,\n            createdAt: user.createdAt,\n            updatedAt: user.updatedAt,\n          },\n        },\n      });\n    } catch (error) {\n      logger.error(\'Get profile error:\', error);\n      return errorResponse(res, {\n        message: \'Failed to retrieve profile\',\n        error: error.message,\n      }, 500);\n    }\n  }\n\n  /**\n   * Update user profile\n   */\n  async updateProfile(req, res) {\n    try {\n      const { user } = req;\n      const {\n        firstName,\n        lastName,\n        phone,\n        profilePicture,\n      } = req.body;\n\n      // Update user\n      await user.update({\n        firstName,\n        lastName,\n        phone,\n        profilePicture,\n      });\n\n      // Return success response\n      return successResponse(res, {\n        message: \'Profile updated successfully\',\n        data: {\n          user: {\n            id: user.id,\n            email: user.email,\n            firstName: user.firstName,\n            lastName: user.lastName,\n            role: user.role,\n            phone: user.phone,\n            profilePicture: user.profilePicture,\n            isVerified: user.isVerified,\n            createdAt: user.createdAt,\n            updatedAt: user.updatedAt,\n          },\n        },\n      });\n    } catch (error) {\n      logger.error(\'Update profile error:\', error);\n      return errorResponse(res, {\n        message: \'Failed to update profile\',\n        error: error.message,\n      }, 500);\n    }\n  }\n\n  /**\n   * Forgot password\n   */\n  async forgotPassword(req, res) {\n    try {\n      const { email } = req.body;\n\n      // Find user\n      const user = await User.findOne({ where: { email } });\n      if (!user) {\n        return errorResponse(res, {\n          message: \'User not found\',\n          code: \'USER_NOT_FOUND\',\n        }, 404);\n      }\n\n      // Generate reset token\n      const resetToken = jwt.sign(\n        { id: user.id },\n        config.jwt.secret,\n        { expiresIn: \'1h\' },\n      );\n\n      // Save reset token\n      await user.update({ resetToken });\n\n      // Send reset email\n      // await sendPasswordResetEmail(user.email, resetToken);\n\n      // Return success response\n      return successResponse(res, {\n        message: \'Password reset instructions sent to your email\',\n      });\n    } catch (error) {\n      logger.error(\'Forgot password error:\', error);\n      return errorResponse(res, {\n        message: \'Failed to process password reset request\',\n        error: error.message,\n      }, 500);\n    }\n  }\n\n  /**\n   * Reset password\n   */\n  async resetPassword(req, res) {\n    try {\n      const { token, newPassword } = req.body;\n\n      // Verify token\n      const decoded = jwt.verify(token, config.jwt.secret);\n\n      // Find user\n      const user = await User.findByPk(decoded.id);\n      if (!user) {\n        return errorResponse(res, {\n          message: \'Invalid or expired token\',\n          code: \'AUTH_TOKEN_INVALID\',\n        }, 400);\n      }\n\n      // Hash new password\n      const saltRounds = config.bcryptSaltRounds;\n      const hashedPassword = await bcrypt.hash(newPassword, saltRounds);\n\n      // Update password and clear reset token\n      await user.update({\n        password: hashedPassword,\n        resetToken: null,\n      });\n\n      // Return success response\n      return successResponse(res, {\n        message: \'Password reset successfully\',\n      });\n    } catch (error) {\n      logger.error(\'Reset password error:\', error);\n      return errorResponse(res, {\n        message: \'Failed to reset password\',\n        error: error.message,\n      }, 400);\n    }\n  }\n}\n\nmodule.exports = new AuthController();\n</full-file-rewrite>\n</function_calls>'}